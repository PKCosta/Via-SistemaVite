{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport type { MiddlewareConfig } from \"next/server\";\r\n\r\n//  Rotas públicas e seu comportamento quando autenticado\r\nconst publicRoutes = [\r\n  { path: \"/sign-in\", whenAuthenticated: \"redirect\" },\r\n  { path: \"/register\", whenAuthenticated: \"redirect\" },\r\n  { path: \"/forgotPassword\", whenAuthenticated: \"redirect\" },\r\n] as const;\r\n\r\n//  Rota padrão para redirecionar quando o usuário não estiver autenticado\r\nconst REDIRECT_WHEN_NOT_AUTHENTICATED_ROUTE = \"/sign-in\";\r\n\r\nexport function middleware(request: NextRequest) {\r\n  const path = request.nextUrl.pathname;\r\n\r\n  // Verifica se a rota atual é pública\r\n  const publicRoute = publicRoutes.find((route) => route.path === path);\r\n\r\n  // Captura o token de autenticação (simples verificação de existência)\r\n  const authToken = request.cookies.get(\"token\")?.value;\r\n\r\n  // 1Caso o usuário não esteja autenticado e esteja acessando uma rota pública → OK\r\n  if (!authToken && publicRoute) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Caso o usuário não esteja autenticado e esteja acessando uma rota privada → redireciona pro login\r\n  if (!authToken && !publicRoute) {\r\n    const redirectUrl = request.nextUrl.clone();\r\n    redirectUrl.pathname = REDIRECT_WHEN_NOT_AUTHENTICATED_ROUTE;\r\n    return NextResponse.redirect(redirectUrl);\r\n  }\r\n\r\n  // Caso o usuário esteja autenticado e tente acessar uma rota pública marcada para redirecionar\r\n  if (authToken && publicRoute && publicRoute.whenAuthenticated === \"redirect\") {\r\n    const redirectUrl = request.nextUrl.clone();\r\n    redirectUrl.pathname = \"/dashboard\"; // destino padrão pós-login\r\n    return NextResponse.redirect(redirectUrl);\r\n  }\r\n\r\n  // Caso o usuário esteja autenticado e acesse uma rota privada → OK\r\n  if (authToken && !publicRoute) {\r\n    // Aqui você poderia futuramente validar expiração do token JWT\r\n    // e até implementar refresh tokens — mas isso é feito no servidor, não no middleware\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Fallback (caso não entre em nenhuma das condições acima)\r\n  return NextResponse.next();\r\n}\r\n\r\n// Define as rotas que o middleware deve interceptar\r\n\r\nexport const config: MiddlewareConfig = {\r\n  matcher: [\r\n    // Aplica o middleware em todas as rotas, exceto:\r\n    // - /api (rotas de API)\r\n    // - _next/static (arquivos estáticos)\r\n    // - _next/image (imagens otimizadas)\r\n    // - favicon, sitemap, robots\r\n    \"/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)\",\r\n  ],\r\n};\r\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AAGA,yDAAyD;AACzD,MAAM,eAAe;IACnB;QAAE,MAAM;QAAY,mBAAmB;IAAW;IAClD;QAAE,MAAM;QAAa,mBAAmB;IAAW;IACnD;QAAE,MAAM;QAAmB,mBAAmB;IAAW;CAC1D;AAED,0EAA0E;AAC1E,MAAM,wCAAwC;AAEvC,SAAS,WAAW,OAAoB;IAC7C,MAAM,OAAO,QAAQ,OAAO,CAAC,QAAQ;IAErC,qCAAqC;IACrC,MAAM,cAAc,aAAa,IAAI,CAAC,CAAC,QAAU,MAAM,IAAI,KAAK;IAEhE,sEAAsE;IACtE,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;IAEhD,kFAAkF;IAClF,IAAI,CAAC,aAAa,aAAa;QAC7B,OAAO,gMAAY,CAAC,IAAI;IAC1B;IAEA,oGAAoG;IACpG,IAAI,CAAC,aAAa,CAAC,aAAa;QAC9B,MAAM,cAAc,QAAQ,OAAO,CAAC,KAAK;QACzC,YAAY,QAAQ,GAAG;QACvB,OAAO,gMAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,+FAA+F;IAC/F,IAAI,aAAa,eAAe,YAAY,iBAAiB,KAAK,YAAY;QAC5E,MAAM,cAAc,QAAQ,OAAO,CAAC,KAAK;QACzC,YAAY,QAAQ,GAAG,cAAc,2BAA2B;QAChE,OAAO,gMAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,mEAAmE;IACnE,IAAI,aAAa,CAAC,aAAa;QAC7B,+DAA+D;QAC/D,qFAAqF;QACrF,OAAO,gMAAY,CAAC,IAAI;IAC1B;IAEA,2DAA2D;IAC3D,OAAO,gMAAY,CAAC,IAAI;AAC1B;AAIO,MAAM,SAA2B;IACtC,SAAS;QACP,iDAAiD;QACjD,wBAAwB;QACxB,sCAAsC;QACtC,qCAAqC;QACrC,6BAA6B;QAC7B;KACD;AACH"}}]
}